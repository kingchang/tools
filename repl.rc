#!/usr/bin/env perl

package Term::ReadLine::NoDuplicates;

use English qw(-no_match_vars);
use Moose;
use MooseX::NonMoose;
use Set::Object ();

extends 'Term::ReadLine';

has history_set =>
    is => 'ro',
    isa => Set::Object::,
    lazy => 1,
    default => sub {Set::Object->new(shift->GetHistory)};

has last_read_line =>
    is => 'rw',
    isa => 'Maybe[Str]';

sub new {
    my $class = shift;
    my $self = bless $class->SUPER::new(@ARG), $class;
    
    $self->StifleHistory(undef);
    return $class->meta->new_object(__INSTANCE__ => $self);
}

# Seems like Term::ReadLine::Gnu uses this one instead.
sub add_history {
    my ($self, @lines) = @ARG;
    my $new_lines = Set::Object->new(@lines) - $self->history_set;
    
    if ($new_lines->size > 0) {
        # Insert new lines.
        $self->history_set->insert($new_lines->elements);
        $self->SUPER::add_history($new_lines->elements);
    }
    else {
        # Move existing lines to the top of the history stack.
        foreach my $line (@lines) {
            my $position = $self->history_search_pos($line, 0, 0);
            
            if ($self->history_get($position + 1) eq $line) {
                $self->remove_history($position);
                $self->SUPER::add_history($line);
            }
        }
    }
    
    return;
}

around readline => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    my $line = $self->$super(@ARG);
    
    $self->last_read_line($line);
    return $line;
};


package Devel::REPL::Plugin::Data::Dumper::Concise;

use Data::Dumper::Concise ();
use Devel::REPL::Plugin;
use English qw(-no_match_vars);
use Scalar::Util ();

around format_result => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    
    if ((@ARG == 1) && defined($ARG[0]) && ("$ARG[0]" eq '')) {
        return $self->$super(@ARG);
    }
    else {
        my $result = Data::Dumper::Concise::Dumper(
            map {$self->prepare_object($ARG)} @ARG);
        
        chomp $result;
        return $self->$super($result);
    }
};


sub prepare_object {
    my ($self, $object) = @ARG;
    
    return overload::Method($object, '""') || Scalar::Util::blessed($object)
        ? "$ARG"
        : $ARG;
}


package Devel::REPL::Plugin::NoHistoryExpansion;

use Devel::REPL::Plugin;
use English qw(-no_match_vars);

around history_call => sub {
    return;
};

around read => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    my $line = $self->$super(@ARG);
    
    if (defined($line) && ($line ne '')) {
        my $index = substr $self->term->last_read_line, 1;
        
        if ($line eq "'Unable to find $index in history'") {
            return $self->term->last_read_line;
        }
    }
    
    return $line;
};


# Current Devel::REPL package.
package main;

use English qw(-no_match_vars);

$_REPL->term(Term::ReadLine::NoDuplicates->new($_REPL->term->{readline_name}));

$_REPL->load_plugins(qw(
    Colors
    Completion
    CompletionDriver::Globals
    CompletionDriver::INC
    CompletionDriver::Keywords
    CompletionDriver::LexEnv
    CompletionDriver::Methods
    Data::Dumper::Concise
    FancyPrompt
    Interrupt
    NoHistoryExpansion
    OutputCache
    ReadLineHistory
    Refresh
));

$_REPL->fancy_prompt(sub {
    my ($self) = @ARG;
    
    return sprintf '%s%s> ',
        $self->current_package,
        $self->line_depth > 0 ? (':' . $self->line_depth) : '';
});

$_REPL->term->Attribs->{history_inhibit_expansion_function} = sub {
    my ($line) = @ARG;
    return $line !~ m/\t/;
};

$_REPL->fancy_continuation_prompt($_REPL->fancy_prompt);
$_REPL->term->Attribs->{history_expansion_char} = 0;

# Terminal defaults:
use defaults;
no strict 'vars';
require List::Util;

use File::Basename;
use File::Slurp;
use List::MoreUtils qw(:all);
use List::Util @List::Util::EXPORT_OK;
use Path::Class;
