#!/usr/bin/env perl

package Term::ReadLine::NoDuplicates;

use English qw(-no_match_vars);
use Moose;
use MooseX::InsideOut;
use Set::Object ();

extends 'Term::ReadLine';

has history_set =>
    is => 'ro',
    isa => Set::Object::,
    lazy => 1,
    default => sub {Set::Object->new(shift->GetHistory)};

has last_read_line =>
    is => 'rw',
    isa => 'Maybe[Str]';

has updated_history =>
    is => 'rw',
    isa => 'Bool';

sub new {
    my $class = shift @ARG;
    my $self = bless
        eval {$Term::ReadLine::Perl::term} // $class->SUPER::new(@ARG),
        $class;
    
    if ($self->can('StifleHistory')) {
        $self->StifleHistory(undef);
    }
    else {
        warn "Unlimited history not available.\n";
    }
    
    return $class->meta->new_object(__INSTANCE__ => $self);
}

around addhistory => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    $self->updated_history(1);
    return $self->_add_history_implementation($super, @ARG);
};

sub add_history {
    my $self = shift @ARG;
    $self->updated_history(1);
    return $self->_add_history_implementation('SUPER::add_history', @ARG);
}

sub _add_history_implementation {
    my ($self, $super, @lines) = @ARG;
    my $new_lines = Set::Object->new(@lines) - $self->history_set;
    
    if ($new_lines->size > 0) {
        # Insert new lines.
        $self->history_set->insert($new_lines->elements);
        $self->$super($new_lines->elements);
    }
    elsif ($self->isa('Term::ReadLine::Gnu')) {
        # Move existing lines to the top of the history stack.
        foreach my $line (@lines) {
            my $position = $self->history_search_pos($line);
            
            if ($self->history_get($position + 1) eq $line) {
                $self->remove_history($position);
                $self->$super($line);
            }
        }
    }
    else {
        warn "History search not available.\n";
    }
    
    return;
}

around readline => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    $self->updated_history(0);
    my $line = $self->$super(@ARG);
    
    # Force history update to reorder it.
    if (!$self->updated_history && defined($line)) {
        $self->add_history($line);
    }
    
    $self->last_read_line($line);
    return $line;
};


package Devel::REPL::Plugin::Data::Dumper::Concise;

use Data::Dumper::Concise ();
use Devel::REPL::Plugin;
use English qw(-no_match_vars);
use Scalar::Util ();
use String::Escape ();

has to_string_length =>
    is => 'ro',
    isa => 'Str',
    default => 1000;

around format_result => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    
    if ((@ARG == 1) && defined($ARG[0]) && ("$ARG[0]" eq '')) {
        return $self->$super(@ARG);
    }
    else {
        my $result = Data::Dumper::Concise::Dumper(
            map {$self->prepare_object($ARG)} @ARG);
        
        chomp $result;
        return $self->$super($result);
    }
};

sub prepare_object {
    my ($self, $object) = @ARG;
    
    if (overload::Method($object, '""')) {
        return "$object";
    }
    elsif (Scalar::Util::blessed($object)) {
        foreach my $to_string (qw(as_string stringify to_string)) {
            if (my $to_string_method = $object->can($to_string)) {
                return String::Escape::elide(
                    $object->$to_string_method,
                    $self->to_string_length);
            }
        }
        
        return "$object";
    }
    else {
        return $object;
    }
}


package Devel::REPL::Plugin::NoHistoryExpansion;

use Devel::REPL::Plugin;
use English qw(-no_match_vars);

around history_call => sub {
    return;
};

around read => sub {
    my ($super, $self) = splice @ARG, 0, 2;
    my $line = $self->$super(@ARG);
    
    if (defined($line) && ($line ne '')) {
        my $index = substr $self->term->last_read_line, 1;
        
        if ($line eq "'Unable to find $index in history'") {
            return $self->term->last_read_line;
        }
    }
    
    return $line;
};


# Current Devel::REPL package.
package main;

use English qw(-no_match_vars);

$_REPL->term(Term::ReadLine::NoDuplicates->new(
    $_REPL->term->Attribs->{readline_name}));

$_REPL->load_plugins(qw(
    Colors
    Completion
    CompletionDriver::Globals
    CompletionDriver::INC
    CompletionDriver::Keywords
    CompletionDriver::LexEnv
    CompletionDriver::Methods
    Data::Dumper::Concise
    FancyPrompt
    Interrupt
    NoHistoryExpansion
    OutputCache
    ReadLineHistory
    Refresh
));

$_REPL->fancy_prompt(sub {
    my ($self) = @ARG;
    
    return sprintf '%s%s> ',
        $self->current_package,
        $self->line_depth > 0 ? (':' . $self->line_depth) : '';
});

$_REPL->term->Attribs->{history_inhibit_expansion_function} = sub {
    my ($line) = @ARG;
    return $line !~ m/\t/;
};

$_REPL->fancy_continuation_prompt($_REPL->fancy_prompt);
$_REPL->term->Attribs->{history_expansion_char} = 0;

# Shell defaults:
use defaults;
no strict 'vars';
require List::Util;

use Data::Dumper::Concise ();
use File::Basename;
use File::Slurp;
use List::MoreUtils qw(:all);
use List::Util @List::Util::EXPORT_OK;
use Path::Class;
use Set::Object;
use URI ();
use URI::QueryParam ();

use Data::Printer {
    class => {
        inherited => 'public',
    },
    color => {
        array => 'blue bold',
        class => 'green',
        code => 'bright_green bold',
        string => 'red',
        undef => 'red bold',
    },
};

sub e {
    Data::Printer::p($ARG[0]);
    return;
}

sub i {
    print Data::Dumper::Concise::Dumper(@ARG);
    return;
}

*explain = \&e;
*inspect = \&i;
*set = \&Set::Object::set;
